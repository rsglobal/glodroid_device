From 5d5bbd001ba027d0b22c51325570b28f52d8a6f5 Mon Sep 17 00:00:00 2001
From: Jernej Skrabec <jernej.skrabec@gmail.com>
Date: Sun, 27 Feb 2022 18:54:21 +0100
Subject: [PATCH 23/23] Improve VP9 decoding

---
 libavcodec/v4l2_request_vp9.c | 110 +++++++++++++++++++---------------
 1 file changed, 62 insertions(+), 48 deletions(-)

diff --git a/libavcodec/v4l2_request_vp9.c b/libavcodec/v4l2_request_vp9.c
index 9b95c76cdb..ec0300f66d 100644
--- a/libavcodec/v4l2_request_vp9.c
+++ b/libavcodec/v4l2_request_vp9.c
@@ -22,78 +22,62 @@
 
 typedef struct V4L2RequestControlsVP9 {
     struct v4l2_ctrl_vp9_frame decode_params;
+    struct v4l2_ctrl_vp9_compressed_hdr chp;
 } V4L2RequestControlsVP9;
 
-static int v4l2_request_vp9_set_frame_ctx(AVCodecContext *avctx)
+static void v4l2_request_vp9_set_frame_ctx(AVCodecContext *avctx)
 {
     VP9Context *s = avctx->priv_data;
-    struct v4l2_ctrl_vp9_compressed_hdr chp;
-    struct v4l2_ext_control control[] = {
-        {
-            .id = V4L2_CID_STATELESS_VP9_COMPRESSED_HDR,
-            .ptr = &chp,
-            .size = sizeof(chp),
-        },
-    };
+    const VP9Frame *f = &s->s.frames[CUR_FRAME];
+    V4L2RequestControlsVP9 *controls = f->hwaccel_picture_private;
+    struct v4l2_ctrl_vp9_compressed_hdr *chp = &controls->chp;
 
-    memset(&chp, 0, sizeof(chp));
+    memset(chp, 0, sizeof(&chp));
 
-    chp.tx_mode = s->s.h.txfmmode;
-    memcpy(chp.tx8, s->prob_raw.p.tx8p, sizeof(s->prob_raw.p.tx8p));
-    memcpy(chp.tx16, s->prob_raw.p.tx16p, sizeof(s->prob_raw.p.tx16p));
-    memcpy(chp.tx32, s->prob_raw.p.tx32p, sizeof(s->prob_raw.p.tx32p));
+    chp->tx_mode = s->s.h.txfmmode;
+    memcpy(chp->tx8, s->prob_raw.p.tx8p, sizeof(s->prob_raw.p.tx8p));
+    memcpy(chp->tx16, s->prob_raw.p.tx16p, sizeof(s->prob_raw.p.tx16p));
+    memcpy(chp->tx32, s->prob_raw.p.tx32p, sizeof(s->prob_raw.p.tx32p));
     for (unsigned i = 0; i < 4; i++) {
         for (unsigned j = 0; j < 2; j++) {
             for (unsigned k = 0; k < 2; k++) {
                 for (unsigned l = 0; l < 6; l++) {
                     for (unsigned m = 0; m < 6; m++) {
-                        memcpy(chp.coef[i][j][k][l][m], s->prob_raw.coef[i][j][k][l][m], sizeof(chp.coef[0][0][0][0][0]));
+                        memcpy(chp->coef[i][j][k][l][m], s->prob_raw.coef[i][j][k][l][m], sizeof(chp->coef[0][0][0][0][0]));
                     }
                 }
             }
         }
     }
-    memcpy(chp.skip, s->prob_raw.p.skip, sizeof(s->prob_raw.p.skip));
-    memcpy(chp.inter_mode, s->prob_raw.p.mv_mode, sizeof(s->prob_raw.p.mv_mode));
-    memcpy(chp.interp_filter, s->prob_raw.p.filter, sizeof(s->prob_raw.p.filter));
-    memcpy(chp.is_inter, s->prob_raw.p.intra, sizeof(s->prob_raw.p.intra));
-    memcpy(chp.comp_mode, s->prob_raw.p.comp, sizeof(s->prob_raw.p.comp));
-    memcpy(chp.single_ref, s->prob_raw.p.single_ref, sizeof(s->prob_raw.p.single_ref));
-    memcpy(chp.comp_ref, s->prob_raw.p.comp_ref, sizeof(s->prob_raw.p.comp_ref));
-    memcpy(chp.y_mode, s->prob_raw.p.y_mode, sizeof(s->prob_raw.p.y_mode));
+    memcpy(chp->skip, s->prob_raw.p.skip, sizeof(s->prob_raw.p.skip));
+    memcpy(chp->inter_mode, s->prob_raw.p.mv_mode, sizeof(s->prob_raw.p.mv_mode));
+    memcpy(chp->interp_filter, s->prob_raw.p.filter, sizeof(s->prob_raw.p.filter));
+    memcpy(chp->is_inter, s->prob_raw.p.intra, sizeof(s->prob_raw.p.intra));
+    memcpy(chp->comp_mode, s->prob_raw.p.comp, sizeof(s->prob_raw.p.comp));
+    memcpy(chp->single_ref, s->prob_raw.p.single_ref, sizeof(s->prob_raw.p.single_ref));
+    memcpy(chp->comp_ref, s->prob_raw.p.comp_ref, sizeof(s->prob_raw.p.comp_ref));
+    memcpy(chp->y_mode, s->prob_raw.p.y_mode, sizeof(s->prob_raw.p.y_mode));
     for (unsigned i = 0; i < 10; i++)
-        memcpy(chp.uv_mode[i], s->prob.p.uv_mode[i], sizeof(s->prob.p.uv_mode[0]));
+        memcpy(chp->uv_mode[i], s->prob.p.uv_mode[i], sizeof(s->prob.p.uv_mode[0]));
     for (unsigned i = 0; i < 4; i++)
-        memcpy(chp.partition[i * 4], s->prob_raw.p.partition[i], sizeof(s->prob_raw.p.partition[0]));
-    memcpy(chp.mv.joint, s->prob_raw.p.mv_joint, sizeof(s->prob_raw.p.mv_joint));
+        memcpy(chp->partition[i * 4], s->prob_raw.p.partition[i], sizeof(s->prob_raw.p.partition[0]));
+    memcpy(chp->mv.joint, s->prob_raw.p.mv_joint, sizeof(s->prob_raw.p.mv_joint));
     for (unsigned i = 0; i < 2; i++) {
-         chp.mv.sign[i] = s->prob_raw.p.mv_comp[i].sign;
-         memcpy(chp.mv.classes[i], s->prob_raw.p.mv_comp[i].classes, sizeof(s->prob_raw.p.mv_comp[0].classes));
-         chp.mv.class0_bit[i] = s->prob_raw.p.mv_comp[i].class0;
-         memcpy(chp.mv.bits[i], s->prob_raw.p.mv_comp[i].bits, sizeof(s->prob_raw.p.mv_comp[0].bits));
-         memcpy(chp.mv.class0_fr[i], s->prob_raw.p.mv_comp[i].class0_fp, sizeof(s->prob_raw.p.mv_comp[0].class0_fp));
-         memcpy(chp.mv.fr[i], s->prob_raw.p.mv_comp[i].fp, sizeof(s->prob_raw.p.mv_comp[0].fp));
-         chp.mv.class0_hp[i] = s->prob_raw.p.mv_comp[i].class0_hp;
-         chp.mv.hp[i] = s->prob_raw.p.mv_comp[i].hp;
+         chp->mv.sign[i] = s->prob_raw.p.mv_comp[i].sign;
+         memcpy(chp->mv.classes[i], s->prob_raw.p.mv_comp[i].classes, sizeof(s->prob_raw.p.mv_comp[0].classes));
+         chp->mv.class0_bit[i] = s->prob_raw.p.mv_comp[i].class0;
+         memcpy(chp->mv.bits[i], s->prob_raw.p.mv_comp[i].bits, sizeof(s->prob_raw.p.mv_comp[0].bits));
+         memcpy(chp->mv.class0_fr[i], s->prob_raw.p.mv_comp[i].class0_fp, sizeof(s->prob_raw.p.mv_comp[0].class0_fp));
+         memcpy(chp->mv.fr[i], s->prob_raw.p.mv_comp[i].fp, sizeof(s->prob_raw.p.mv_comp[0].fp));
+         chp->mv.class0_hp[i] = s->prob_raw.p.mv_comp[i].class0_hp;
+         chp->mv.hp[i] = s->prob_raw.p.mv_comp[i].hp;
     }
-
-    return ff_v4l2_request_set_controls(avctx, control, FF_ARRAY_ELEMS(control));
 }
 
-static int v4l2_request_vp9_start_frame(AVCodecContext *avctx,
-                                        av_unused const uint8_t *buffer,
-                                        av_unused uint32_t size)
+static void fill_frame(struct v4l2_ctrl_vp9_frame *dec_params, AVCodecContext *avctx)
 {
     const VP9Context *s = avctx->priv_data;
-    const VP9Frame *f = &s->s.frames[CUR_FRAME];
-    V4L2RequestControlsVP9 *controls = f->hwaccel_picture_private;
-    struct v4l2_ctrl_vp9_frame *dec_params = &controls->decode_params;
     const ThreadFrame *ref;
-    int ret;
-
-    ret = v4l2_request_vp9_set_frame_ctx(avctx);
-    if (ret)
-	return ret;
 
     memset(dec_params, 0, sizeof(*dec_params));
 
@@ -208,6 +192,19 @@ static int v4l2_request_vp9_start_frame(AVCodecContext *avctx,
         if (s->s.h.segmentation.feat[i].skip_enabled)
             dec_params->seg.feature_enabled[i] |= 1 << V4L2_VP9_SEG_LVL_SKIP;
     }
+}
+
+static int v4l2_request_vp9_start_frame(AVCodecContext *avctx,
+                                        av_unused const uint8_t *buffer,
+                                        av_unused uint32_t size)
+{
+    const VP9Context *s = avctx->priv_data;
+    const VP9Frame *f = &s->s.frames[CUR_FRAME];
+    V4L2RequestControlsVP9 *controls = f->hwaccel_picture_private;
+
+    v4l2_request_vp9_set_frame_ctx(avctx);
+
+    fill_frame(&controls->decode_params, avctx);
 
     return ff_v4l2_request_reset_frame(avctx, f->tf.f);
 }
@@ -233,6 +230,11 @@ static int v4l2_request_vp9_end_frame(AVCodecContext *avctx)
             .ptr = &controls->decode_params,
             .size = sizeof(controls->decode_params),
         },
+        {
+            .id = V4L2_CID_STATELESS_VP9_COMPRESSED_HDR,
+            .ptr = &controls->chp,
+            .size = sizeof(controls->chp),
+        },
     };
 
     ret = ff_v4l2_request_decode_frame(avctx, f->tf.f, control, FF_ARRAY_ELEMS(control));
@@ -247,8 +249,20 @@ static int v4l2_request_vp9_end_frame(AVCodecContext *avctx)
 
 static int v4l2_request_vp9_init(AVCodecContext *avctx)
 {
+    struct v4l2_ctrl_vp9_frame frame;
+
+    struct v4l2_ext_control control[] = {
+        {
+            .id = V4L2_CID_STATELESS_VP9_FRAME,
+            .ptr = &frame,
+            .size = sizeof(frame),
+        },
+    };
+
+    fill_frame(&frame, avctx);
+
     // TODO: check V4L2_CID_MPEG_VIDEO_VP9_PROFILE
-    return ff_v4l2_request_init(avctx, V4L2_PIX_FMT_VP9_FRAME, 3 * 1024 * 1024, NULL, 0);
+    return ff_v4l2_request_init(avctx, V4L2_PIX_FMT_VP9_FRAME, 3 * 1024 * 1024, control, FF_ARRAY_ELEMS(control));
 }
 
 const AVHWAccel ff_vp9_v4l2request_hwaccel = {
-- 
2.37.2

